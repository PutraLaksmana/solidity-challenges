// SPDX-License-Identifier: MIT
pragma solidity 0.8.25;

import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";

contract Mimic is AccessControl {
    /// @dev Triggered when a user tries to donate 0 ether.
    error InsufficientFunds();

    /// @dev Triggered when the owner tries to withdraw 0 ether.
    error NoFundsToWithdraw();

    ///@dev Emits when a user donates to the contract.
    event Donated(address indexed donor, uint256 amount);

    bytes32 public constant OWNER_ROLE = keccak256("OWNER_ROLE");

    mapping(address => uint256) public donations;

    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    /**
     * @dev Allows users to donate to the contract.
     */
    function donate() external payable {
        if (msg.value == 0) {
            revert InsufficientFunds();
        }

        donations[msg.sender] += msg.value;
    }

    /**
     * @dev Allows the owner to withdraw funds from the contract.
     */
    function withdraw() external onlyRole(OWNER_ROLE) {
        address sender = msg.sender;

        uint256 balance = address(this).balance;
        require(balance > 0, "No funds to withdraw");

        if (balance == 0) {
            revert NoFundsToWithdraw();
        }

        payable(sender).transfer(balance);
        emit Donated(sender, balance);
    }

    /**
     * @dev Allows users to refund their donations.
     */
    function refund() external {
        address sender = msg.sender;
        uint256 refundAmount = donations[sender];

        if (refundAmount == 0) {
            revert NoFundsToWithdraw();
        }

        donations[sender] = 0;
        payable(sender).transfer(refundAmount);
    }

    /**
     * @dev Grants a role to an account.
     * Can only be called by the contract owner.
     */
    function grantRole(bytes32 role, address account) public override {
        _grantRole(role, account);
    }

    receive() external payable {}
    fallback() external payable {}
}
